# æ‰€æœ‰æƒ

æ‰€æœ‰æƒæ˜¯ Rust æœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œå®ƒè®© Rust æ— éœ€ GC å°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨

In this chapter, weâ€™ll talk about ownership as well as several related features: **borrowing**, **slices**, and how Rust **lays data out in memory**.

## ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒ

Rust çš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ

æ‰€æœ‰ç¨‹åºåœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†å®ƒä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼

- æœ‰äº›è¯­è¨€æœ‰åƒåœ¾æ”¶é›†æœºåˆ¶ï¼ˆC#ï¼Œjavaï¼‰ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œå®ƒä»¬ä¼šä¸æ–­åœ°å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜

- åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼ˆC/C++ï¼‰ï¼Œç¨‹åºå‘˜å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜

Rust é‡‡ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼ï¼š

- å†…å­˜æ˜¯é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†çš„ï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
- Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the **compiler checks**. If any of the rules are violated, the program wonâ€™t compile. None of the features of ownership will slow down your program while itâ€™s running.

## Stack vs Heap 

æ ˆå†…å­˜ vs å †å†…å­˜

åœ¨åƒ Rust è¿™æ ·çš„ç³»ç»Ÿçº§ç¼–ç¨‹è¯­è¨€é‡Œï¼Œä¸€ä¸ªå€¼æ˜¯åœ¨ stack ä¸Šè¿˜æ˜¯åœ¨ heap ä¸Šå¯¹è¯­è¨€çš„è¡Œä¸ºå’Œä½ ä¸ºä»€ä¹ˆè¦åšæŸäº›å†³å®šæ˜¯æœ‰æ›´å¤§çš„å½±å“çš„

### å­˜å‚¨æ•°æ®

Stack æŒ‰å€¼çš„æ¥æ”¶é¡ºåºæ¥å­˜å‚¨ï¼ŒæŒ‰ç›¸åçš„é¡ºåºå°†å®ƒä»¬ç§»é™¤ï¼ˆåè¿›å…ˆå‡ºï¼ŒLIFOï¼‰

- æ·»åŠ æ•°æ®å«åšå‹å…¥æ ˆ

- ç§»é™¤æ•°æ®å«åšå¼¹å‡ºæ ˆ

**æ‰€æœ‰å­˜å‚¨åœ¨ Stack ä¸Šçš„æ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥çš„å›ºå®šçš„å¤§å°**

**ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„æ•°æ®æˆ–è¿è¡Œæ—¶å¤§å°å¯èƒ½å‘ç”Ÿå˜åŒ–çš„æ•°æ®å¿…é¡»å­˜æ”¾åœ¨ heap ä¸Š**

> docï¼š All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.

Heap å†…å­˜ç»„ç»‡æ€§å·®ä¸€äº›ï¼š

- å½“ä½ æŠŠæ•°æ®æ”¾å…¥ heap æ—¶ï¼Œä½ ä¼šè¯·æ±‚ä¸€å®šæ•°é‡çš„ç©ºé—´

- æ“ä½œç³»ç»Ÿåœ¨ heap é‡Œæ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºåœ¨ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªç©ºé—´çš„åœ°å€

- å› ä¸ºæŒ‡é’ˆæ˜¯å·²çŸ¥å›ºå®šå¤§å°çš„ï¼Œå¯ä»¥æŠŠæŒ‡é’ˆå­˜æ”¾åœ¨ stack ä¸Š
- ä½†å¦‚æœæƒ³è¦å®é™…æ•°æ®ï¼Œä½ å¿…é¡»ä½¿ç”¨æŒ‡é’ˆæ¥å®šä½

æŠŠæ•°æ®å‹åˆ° stack ä¸Šè¦æ¯”åœ¨ heap ä¸Šåˆ†é…å¿«å¾—å¤šï¼Œå› ä¸ºåœ¨ heap ä¸Šåˆ†é…ç©ºé—´éœ€è¦åšæ›´å¤šçš„å·¥ä½œï¼šæ“ä½œç³»ç»Ÿé¦–å…ˆéœ€è¦æ‰¾åˆ°ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç©ºé—´æ¥å­˜æ”¾æ•°æ®ï¼Œç„¶åè¦åšå¥½è®°å½•æ–¹ä¾¿ä¸‹æ¬¡åˆ†é…

è®¿é—® heap ä¸­çš„æ•°æ®è¦æ¯”è®¿é—® stack ä¸­çš„æ•°æ®æ…¢ï¼Œå› ä¸ºéœ€è¦é€šè¿‡æŒ‡é’ˆæ‰èƒ½æ‰¾åˆ° heap ä¸­çš„æ•°æ®

å¯¹äºç°ä»£çš„å¤„ç†å™¨æ¥è¯´ï¼Œç”±äºç¼“å­˜çš„ç¼˜æ•…ï¼Œå¦‚æœæŒ‡ä»¤åœ¨å†…å­˜ä¸­è·³è½¬çš„æ¬¡æ•°è¶Šå°‘ï¼Œé‚£ä¹ˆé€Ÿåº¦å°±è¶Šå¿«

å¦‚æœæ•°æ®å­˜æ”¾çš„è·ç¦»æ¯”è¾ƒè¿‘ï¼Œé‚£ä¹ˆå¤„ç†å™¨çš„å¤„ç†é€Ÿåº¦å°±ä¼šæ›´å¿«ä¸€äº›ï¼ˆstack ä¸Šï¼‰

å¦‚æœæ•°æ®ä¹‹é—´çš„è·ç¦»æ¯”è¾ƒè¿œï¼Œé‚£ä¹ˆå¤„ç†é€Ÿåº¦å°±ä¼šæ…¢ä¸€äº›ï¼ˆheap ä¸Šï¼‰

- åœ¨ heap ä¸Šåˆ†é…å¤§é‡çš„ç©ºé—´ä¹Ÿæ˜¯éœ€è¦æ—¶é—´çš„

### å‡½æ•°è°ƒç”¨

å½“ä½ çš„ä»£ç è°ƒç”¨å‡½æ•°æ—¶ï¼Œå€¼è¢«ä¼ å…¥åˆ°å‡½æ•°ï¼ˆä¹ŸåŒ…æ‹¬æŒ‡å‘ heap çš„æŒ‡é’ˆï¼‰ã€‚å‡½æ•°æœ¬åœ°çš„å˜é‡è¢«å‹åˆ° stack ä¸Šã€‚å½“å‡½æ•°ç»“æŸåï¼Œè¿™äº›å€¼ä¼šä» stack ä¸Šå¼¹å‡º

### æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› 

æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜ï¼š

- è·Ÿè¸ªä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ heap çš„å“ªäº›æ•°æ®

- æœ€å°åŒ– heap ä¸Šçš„é‡å¤æ•°æ®é‡

- æ¸…ç† heap ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³

ä¸€æ—¦ä½ æ‡‚çš„äº†æ‰€æœ‰æƒï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦ç»å¸¸å»æƒ³ stack æˆ– heap äº†

> Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you donâ€™t run out of space are all problems that ownership addresses. Once you understand ownership, you wonâ€™t need to think about the stack and the heap very often, but knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does.

## æ‰€æœ‰æƒè§„åˆ™

- æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
- æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
- å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤

> - Each value in Rust has an *owner*.
> - There can only be one owner at a time.
> - When the owner goes out of scope, the value will be dropped.

### å˜é‡ä½œç”¨åŸŸ

Scope å°±æ˜¯ç¨‹åºä¸­ä¸€ä¸ªé¡¹ç›®çš„æœ‰æ•ˆèŒƒå›´ï¼Œä¸å…¶ä»–è¯­è¨€ç±»ä¼¼

### String ç±»å‹

å­—ç¬¦ä¸²å­—é¢å€¼ï¼ˆString literals or strï¼‰ï¼šç¨‹åºé‡Œæ‰‹å†™çš„é‚£äº›å­—ç¬¦ä¸²å€¼ã€‚å®ƒä»¬æ˜¯å¤§å°å·²çŸ¥çš„ï¼Œä¸å¯å˜çš„ï¼ˆimmutableï¼‰ï¼Œå› æ­¤è¢«åˆ†é…åœ¨ stack ä¸Š

Rust è¿˜æœ‰ç¬¬äºŒç§å­—ç¬¦ä¸²ç±»å‹ï¼šStringã€‚String æ¯”é‚£äº›åŸºç¡€æ ‡é‡æ•°æ®ç±»å‹æ›´å¤æ‚ï¼Œ**å­˜å‚¨åœ¨å †ä¸Š**

> Rust has a second string type, `String`. This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a `String` from a string literal using the `from` function

**åˆ›å»º String ç±»å‹çš„å€¼**

- å¯ä»¥ä½¿ç”¨ from å‡½æ•°ä»å­—ç¬¦ä¸²å­—é¢å€¼åˆ›å»ºå‡º String ç±»å‹

- `let s = String::from("123!");`
    - â€œ:â€ è¡¨ç¤º from æ˜¯ String ç±»å‹ä¸‹çš„å‡½æ•°

- è¿™ç±»å­—ç¬¦ä¸²æ˜¯å¯ä»¥è¢«ä¿®æ”¹çš„

```rust
let mut s = String::from("Hello");
s.push_str(", world!");
println!("{}", s);
```

### å†…å­˜å’Œåˆ†é…

- å­—ç¬¦ä¸²å­—é¢å€¼ï¼Œåœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“å®ƒçš„å†…å®¹äº†ï¼Œå…¶æ–‡æœ¬å†…å®¹ç›´æ¥è¢«ç¡¬ç¼–ç åˆ°æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶é‡Œ
    - é€Ÿåº¦å¿«ã€é«˜æ•ˆã€‚æ˜¯å› ä¸ºå…¶ä¸å¯å˜æ€§

- `String` ç±»å‹ï¼Œä¸ºäº†æ”¯æŒå¯å˜æ€§ï¼Œéœ€è¦åœ¨ `heap` ä¸Šåˆ†é…å†…å­˜æ¥ä¿å­˜ç¼–è¯‘æ—¶æœªçŸ¥çš„æ–‡æœ¬å†…å®¹
    - æ“ä½œç³»ç»Ÿå¿…é¡»åœ¨è¿è¡Œæ—¶æ¥è¯·æ±‚å†…å­˜ï¼Œè¿™æ­¥é€šè¿‡è°ƒç”¨ `String::from` æ¥å®ç°
    - å½“ç”¨å®Œ `String` ä¹‹åï¼Œéœ€è¦ä½¿ç”¨æŸç§æ–¹å¼å°†å†…å­˜è¿”å›ç»™æ“ä½œç³»ç»Ÿ
        - è¿™æ­¥ï¼Œåœ¨æ‹¥æœ‰ GC çš„è¯­è¨€ä¸­ï¼ŒGC ä¼šè·Ÿè¸ªå¹¶æ¸…ç†ä¸å†ä½¿ç”¨çš„å†…å­˜
        - æ²¡æœ‰ GCï¼Œå°±éœ€è¦æˆ‘ä»¬å»è¯†åˆ«å†…å­˜ä½•æ—¶ä¸å†ä½¿ç”¨ï¼Œå¹¶è°ƒç”¨ä»£ç å°†å®ƒè¿”å›
        - å¦‚æœå¿˜äº†ï¼Œé‚£å°±æµªè´¹å†…å­˜
        - å¦‚æœæå‰åšäº†ï¼Œå˜é‡å°±ä¼šéæ³•
        - å¦‚æœåšäº†ä¸¤æ¬¡ï¼Œä¹Ÿæ˜¯ Bugã€‚å¿…é¡»ä¸€æ¬¡åˆ†é…å¯¹åº”ä¸€æ¬¡é‡Šæ”¾

- Rust é‡‡ç”¨äº†ä¸åŒçš„æ–¹å¼ï¼šå¯¹äºæŸä¸ªå€¼æ¥è¯´ï¼Œå½“æ‹¥æœ‰å®ƒçš„å˜é‡èµ°å‡ºä½œç”¨èŒƒå›´æ—¶ï¼Œå†…å­˜ä¼šç«‹å³è‡ªåŠ¨çš„äº¤è¿˜ç»™æ“ä½œç³»ç»Ÿ

- `drop` å‡½æ•°

doc åŸæ–‡ï¼š

Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope. Hereâ€™s a version of our scope example from Listing 4-1 using a `String` instead of a string literal:

```rust
fn main() {
    {
        let s = String::from("hello"); // s is valid from this point forward
        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
}
```

There is a natural point at which we can return the memory our `String` needs to the allocator: when `s` goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop), and itâ€™s where the author of `String` can put the code to return the memory. Rust calls `drop` automatically at the closing curly bracket.

> Note: In C++, this pattern of deallocating resources at the end of an itemâ€™s lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*. The `drop` function in Rust will be familiar to you if youâ€™ve used RAII patterns.

This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data weâ€™ve allocated on the heap. Letâ€™s explore some of those situations now.

### å˜é‡å’Œæ•°æ®äº¤äº’çš„æ–¹å¼ï¼šç§»åŠ¨ï¼ˆMoveï¼‰

å¤šä¸ªå˜é‡å¯ä»¥ä¸åŒä¸€ä¸ªæ•°æ®ä½¿ç”¨ä¸€ç§ç‹¬ç‰¹çš„æ–¹å¼æ¥äº¤äº’

```rust
let x = 5;
let y = x;
```

æ•´æ•°æ˜¯å·²çŸ¥ä¸”å›ºå®šå¤§å°çš„ç®€å•çš„å€¼ï¼Œè¿™ä¸¤ä¸ª 5 è¢«å‹åˆ°äº† stack ä¸­ã€‚æ³¨æ„ï¼šå¯¹äºè¿™ç§å¤§å°å·²çŸ¥çš„å˜é‡ï¼Œrust åœ¨ stack ä¸­è¿›è¡Œå¤åˆ¶æ“ä½œï¼Œx,y å„è‡ªå­˜äº†ä¸€ä¸ª5

**String ç‰ˆæœ¬**

```rust
let s1 = String::from("hello");
let s2 = s1; // å…¶ä»–è¯­è¨€ä¸­ï¼Œåªæ˜¯æµ…æ‹·è´äº†ä¸€ä»½æ ˆä¸Šçš„æ•°æ®ï¼ˆä¸¤ä¸ªå¼•ç”¨æŒ‡å‘åŒä¸€ä»½å †å†…å­˜ï¼‰ï¼Œä»è€Œå‘ç”Ÿ double free bug
```

ä¸ºäº†ä¿è¯å†…å­˜å®‰å…¨ï¼š
- Rust æ²¡æœ‰å°è¯•å¤åˆ¶è¢«åˆ†é…çš„å†…å­˜ğŸ‘
- Rust è®© s1å¤±æ•ˆï¼Œç±»ä¼¼äº C++ ä¸­çš„ `std::move()`
  - è¿™æ ·ï¼Œå½“ s1ç¦»å¼€ä½œç”¨åŸŸçš„æ—¶å€™ï¼ŒRust ä¸éœ€è¦é‡Šæ”¾ä»»ä½•ä¸œè¥¿

### å˜é‡å’Œæ•°æ®äº¤äº’çš„æ–¹å¼ï¼šå…‹éš†ï¼ˆCloneï¼‰

å¦‚æœçœŸæƒ³å¯¹ heap ä¸Šé¢çš„ String æ•°æ®è¿›è¡Œæ·±åº¦æ‹·è´ï¼Œè€Œä¸ä»…ä»…æ˜¯ stack ä¸Šçš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ clone æ–¹æ³•ï¼ˆä»¥åå†ç»†è¯´ï¼Œå…ˆçœ‹ä¸ªä¾‹å­)

```rust
let s1 = String::from("Hello");
let s2 = s1.clone();
println!("{}, {}", s1, s2);
```

### Stack ä¸Šçš„æ•°æ®ï¼šå¤åˆ¶

Thereâ€™s another wrinkle we havenâ€™t talked about yet. This code using integers â€“ part of which was shown in Listing 4-2 â€“ works and is valid:

```rust
fn main() {
    let x = 5;
    let y = x;
    println!("x = {}, y = {}", x, y);
}
```

But this code seems to contradict what we just learned: we donâ€™t have a call to `clone`, but `x` is still valid and wasnâ€™t moved into `y`.

The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means thereâ€™s no reason we would want to prevent `x` from being valid after we create the variable `y`. In other words, thereâ€™s no difference between deep and shallow copying here, so calling `clone` wouldnâ€™t do anything different from the usual shallow copying and we can leave it out.

Rust has a special annotation called the `Copy` trait that we can place on types that are stored on the stack, as integers are (weâ€™ll talk more about traits in [Chapter 10](https://doc.rust-lang.org/book/ch10-02-traits.html)). If a type implements the `Copy` trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable.

Copy trait æ¥å£ï¼Œå¯ä»¥ç”¨äºåƒæ•´æ•°è¿™æ ·å®Œå…¨å­˜æ”¾åœ¨ stack ä¸Šé¢çš„ç±»å‹

å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† Copy è¿™ä¸ª traitï¼Œé‚£ä¹ˆæ—§çš„å˜é‡åœ¨èµ‹å€¼åä»ç„¶å¯ç”¨ï¼

å¦‚æœä¸€ä¸ªç±»å‹æˆ–è€…è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† Drop traitï¼Œé‚£ä¹ˆã€Rust ä¸å…è®¸è®©å®ƒå†å»å®ç° Copy trait äº†

**ä¸€äº›æ‹¥æœ‰ Copy trait çš„ç±»å‹**

- ä»»ä½•**ç®€å•æ ‡é‡**çš„ç»„åˆç±»å‹éƒ½å¯ä»¥æ˜¯ Copy çš„

- ä»»ä½•éœ€è¦**åˆ†é…å†…å­˜æˆ–æŸç§èµ„æº**çš„éƒ½ä¸æ˜¯ Copyçš„

- ä¸€äº›æ‹¥æœ‰ Copy trait çš„ç±»å‹ï¼š
    - æ‰€æœ‰çš„æ•´æ•°ç±»å‹ï¼Œä¾‹å¦‚ u32
    - bool
    - char
    - æ‰€æœ‰çš„æµ®ç‚¹ç±»å‹ï¼Œä¾‹å¦‚ f64
    - Tuple ï¼ˆå…ƒç»„ï¼‰ï¼Œå¦‚æœå…¶æ‰€æœ‰çš„å­—æ®µéƒ½æ˜¯ Copy çš„ï¼Œä¾‹å¦‚ `(u32, i32)`

## æ‰€æœ‰æƒä¸å‡½æ•°

åœ¨è¯­ä¹‰ä¸Šï¼Œå°†å€¼ä¼ é€’ç»™å‡½æ•°å’ŒæŠŠå€¼èµ‹ç»™å˜é‡æ˜¯ç±»ä¼¼çš„ï¼š

- å°†å€¼ä¼ é€’ç»™å‡½æ•°å°†å‘ç”Ÿ**ç§»åŠ¨**æˆ–**å¤åˆ¶**ï¼Œå–å†³äºå€¼æ‰€åœ¨çš„ä½ç½®

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

### è¿”å›å€¼ä¸ä½œç”¨åŸŸ

å‡½æ•°åœ¨è¿”å›å€¼çš„è¿‡ç¨‹ä¸­åŒæ ·ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»

ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼ï¼š

- æŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶å®ƒå˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨

- å½“ä¸€ä¸ªåŒ…å« heap æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢« drop å‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†

### å¦‚ä½•è®©å‡½æ•°ä½¿ç”¨æŸä¸ªå€¼ï¼Œä½†ä¸è·å¾—å…¶æ‰€æœ‰æƒ

ç›®å‰çš„åšæ³•å¦‚ä¸‹ï¼š

```rust
fn main() {
    let s1 = String::from("hello");
    let (s2, len) = calculate_length(s1);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}
```

åé¢å°†ä¼šä½¿ç”¨**å¼•ç”¨**è§£å†³è¿™ä¸ªé—®é¢˜

